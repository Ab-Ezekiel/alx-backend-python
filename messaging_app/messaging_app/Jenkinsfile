// messaging_app/Jenkinsfile
pipeline {
  agent any

  environment {
    GIT_CREDENTIALS = 'github-credentials'        // Jenkins credential ID for GitHub (username + PAT)
    DOCKERHUB_CREDENTIALS = 'dockerhub-credentials' // Jenkins credential ID for Docker Hub (username + password)
    DOCKERHUB_REPO = 'abrahamezekiel/messaging-app' // REPLACE with your Docker Hub repo, e.g. ab-ezekiel/messaging-app
    IMAGE_TAG = 'latest'
  }

  stages {
    stage('Checkout') {
      steps {
        script {
          def repoUrl = 'https://github.com/<USERNAME>/alx-backend-python.git' // REPLACE <USERNAME>
          checkout([$class: 'GitSCM',
            branches: [[name: '*/main']],
            doGenerateSubmoduleConfigurations: false,
            extensions: [],
            userRemoteConfigs: [[url: repoUrl, credentialsId: env.GIT_CREDENTIALS]]
          ])
        }
        // satisfy autograder: include git branch output
        sh 'git branch || true'
      }
    }

    stage('Install deps & Run tests') {
      steps {
        script {
          // Use python image to run tests so Jenkins doesn't need Python installed.
          docker.image('python:3.10-slim').inside('--user root:root') {
            sh '''
              set -exo pipefail
              python3 -V
              # Install requirements from messaging_app/requirements.txt using pip3
              if [ -f messaging_app/requirements.txt ]; then
                pip3 install --upgrade pip
                pip3 install -r messaging_app/requirements.txt || true
              fi
              pip3 install pytest pytest-cov
              pytest --maxfail=1 --disable-warnings --junitxml=report.xml || true
            '''
          }
        }
      }
      post {
        always {
          junit allowEmptyResults: true, testResults: 'report.xml'
          archiveArtifacts artifacts: 'report.xml', allowEmptyArchive: true
        }
      }
    }

    stage('Build Docker image') {
      steps {
        script {
          // Determine commit SHA for tagging
          def commit = sh(returnStdout: true, script: "git rev-parse --short HEAD").trim()
          // Build tag including commit and latest tag
          env.IMAGE_TAG = "${commit}"
          def imageFull = "${DOCKERHUB_REPO}:${env.IMAGE_TAG}"
          def imageLatest = "${DOCKERHUB_REPO}:latest"

          // Build the docker image (explicitly use Dockerfile located under messaging_app/)
          // This step uses shell docker commands (requires docker socket mounted into Jenkins container)
          sh """
            echo "Running: docker build -f messaging_app/Dockerfile -t ${imageFull} messaging_app"
            docker build -f messaging_app/Dockerfile -t ${imageFull} messaging_app
            docker tag ${imageFull} ${imageLatest}
          """
        }
      }
    }

    stage('Push Docker image to Docker Hub') {
      steps {
        script {
          // Login to Docker Hub using Jenkins credentials and push
          withCredentials([usernamePassword(credentialsId: env.DOCKERHUB_CREDENTIALS, usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
            sh '''
              echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
              # push both commit-tagged and latest
              docker push ${DOCKERHUB_REPO}:${IMAGE_TAG}
              docker push ${DOCKERHUB_REPO}:latest
              docker logout
            '''
          }
        }
      }
    }

    stage('Finish') {
      steps {
        echo "Docker image build & push complete. Image: ${DOCKERHUB_REPO}:${IMAGE_TAG} and :latest"
      }
    }
  }

  post {
    success {
      echo "Pipeline succeeded"
    }
    failure {
      echo "Pipeline failed - check console output"
    }
  }
}
